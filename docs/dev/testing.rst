.. _testing:

===============================================================================
Testing PUDL
===============================================================================
Our test suite is primarily written using `pytest <https://pytest.org>`__.
The tests are all stored under the `test/` directory in the main repository,
and they are organized into 3 broad categories, each with its own subdirectory:

* **Software Unit Tests** (in `test/unit/`) can be run in seconds and don't
  require any external data. They test the basic functionality of various
  functions and classes, often using minimal inline data structures that are
  specified in the test modules themselves.
* **Software Integration Tests** (in `test/integration/`) test larger
  collections of functionality, including the interactions between different
  parts of the overall software system, and in some cases interactions with
  external systems, requiring network connectivity. The main thing our
  integration tests do is run the full PUDL data processing pipeline for the
  most recent year of data. This can take around 15 minutes.
* **Data Validations** (in `test/validate/`) sanity check the PUDL outputs
  generated by the data processing pipeline. This helps us catch issues with
  the input data, and more subtle bugs that don't prevent the code from
  executing, but do have unintended or unexpected impacts on the output data.
  The data validation is very different from the other tests, and has its
  own page: :doc:`/dev/data_validation`.

-------------------------------------------------------------------------------
Running tests with Tox
-------------------------------------------------------------------------------
We use `Tox <https://tox.readthedocs.io>`__ to coordinate running different
groups of tests together, and to make sure that the tests are run in a pristine
environment that isn't contaminated by other packages which have been installed
locally, but that won't necessarily be installed by users. Tox's behavior is
configured with the `tox.ini` file in the main repository directory. There are
several different "test environments" defined, to test different aspects of
the software, or to perform other actions like building the documentation. To
see a list of the available environments with short descriptions run the
following command in the main repo directory:

.. code-block:: console

    $ tox -av

Software Unit and Integration Tests
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
To run one of those sets of tests, you use the `-e` flag. To run the software
unit tests mentioned above, you'd use:

.. code-block:: console

    $ tox -e unit

And to run the software integration tests you could do:

.. code-block:: console

    $ tox -e integration

Continuous Integration Tests
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
When code is pushed to our GitHub repo, or you make a pull request against the
PUDL repository, a bunch of other continuous integration (CI) checks are run
automatically by a `GitHub Action <https://github.com/features/actions>`__.
This includes linting the code and documentation input files, and trying to
build the documentation.

Before checking code into GitHub, we run all the same tests locally so we can
catch errors early and fix them. There's a Tox test environment named ``ci``
that takes care of this, which you can run with:

.. code-block:: console

    $ tox -re ci

The ``-r`` is short for ``--recreate`` and it tells Tox to recreate the testing
software environment from scratch. This is only strictly necessary if software
dependencies have changed, but it's not a bad idea to just to make sure
everything is fresh, as it will be on the CI test runner. You can use this
option with any of the test environments if any dependencies have changed.

Running Other Commands with Tox
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
You can run any of the individual test environments that ``tox -av`` lists on
their own.  Not all of them literally run tests. For instance, to lint and
build the documentation you can run:

.. code-block:: console

    $ tox -e docs

To run all of the code and documentation linters, but not run any of the other
tests:

.. code-block:: console

    $ tox -e linters

Each of the test environments defined in ``tox.ini`` is just a collection of
dependencies and commands. To see what they consist of, you can open the file
in your text editor. Each section starts with ``[testenv:xxxxxx]`` and the
section called ``commands`` is a list of shell commands that that test
environment will run.

-------------------------------------------------------------------------------
Input Data for Integration Tests
-------------------------------------------------------------------------------
The software integration tests need a year's worth of input data to process. By
default they will look in your local PUDL datastore to find it. If the data
they need isn't available locally, they will download it from Zenodo and put it
in the local datastore.

However, if you're editing code that affects how the datastore works, you
probably don't want to risk it contaminating your working datastore. You can
tell it to use a disposable temporary datastore instead by having Tox pass the
``--tmp-data`` flag in to ``pytest`` like this:

.. code-block:: console

   $ tox -e integration -- --tmp-data

The floating ``--`` isn't a typo, it tells Tox that you're done giving it
command line arguments, and that any additional arguments it gets should be
passed through to ``pytest`` instead, and we've configured ``pytest`` (through
the ``test/conftest.py`` configuration file) to be on the lookout for the
``--tmp-data`` flag and act accordingly.

.. seealso::

    * :doc:`/usage` for more on how to set up a PUDL workspace, including a
      datastore.
    * :doc:`/datastore` for more on how to work with the datastore.

-------------------------------------------------------------------------------
Running pytest independently
-------------------------------------------------------------------------------
Running tests directly with ``pytest`` gives you the ability to run only tests
from a particular test module, or even a single individual test case. It's also
faster because there's no testing environment to set up. Instead it just uses
your Python environment, which should be the ``pudl-dev`` conda environment
discussed in :doc:`/dev/dev_setup`.  This is convenient if you're debugging
something specific, or developing new test cases, but it's not as robust as
using Tox.

To run the software unit tests with ``pytest`` directly:

.. code-block:: console

   $ pytest test/unit

To run only the unit tests for the Excel spreadsheet extraction module:

.. code-block:: console

   $ pytest test/unit/extract/excel_test.py

To run only the unit tests defined by a single test class within that module:

.. code-block:: console

   $ pytest test/unit/extract/excel_test.py::TestGenericExtractor

To run the ETL portion of the integration tests, and force it to download fresh
input data to a temporary directory:

.. code-block:: console

   $ pytest --tmp-data test/integration/etl_test.py
